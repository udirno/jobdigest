---
phase: 01-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - manifest.json
  - src/background.js
  - src/storage.js
  - src/errors.js
  - src/popup.html
  - src/popup.css
  - icons/icon16.png
  - icons/icon48.png
  - icons/icon128.png
autonomous: true

must_haves:
  truths:
    - "Extension loads in Chrome without errors via chrome://extensions"
    - "Storage abstraction reads and writes to chrome.storage.local"
    - "Error utilities produce structured error objects with user-friendly messages"
  artifacts:
    - path: "manifest.json"
      provides: "Manifest V3 configuration with correct permissions"
      contains: "manifest_version.*3"
    - path: "src/storage.js"
      provides: "Storage abstraction layer wrapping chrome.storage.local"
      exports: ["storage"]
      min_lines: 60
    - path: "src/errors.js"
      provides: "Error handling utilities with exponential backoff and user-friendly messages"
      exports: ["ApiError", "retryWithBackoff", "getUserMessage"]
      min_lines: 50
    - path: "src/background.js"
      provides: "Service worker entry point"
      min_lines: 10
  key_links:
    - from: "src/background.js"
      to: "src/storage.js"
      via: "importScripts or ES module import"
      pattern: "import.*storage|importScripts.*storage"
    - from: "manifest.json"
      to: "src/background.js"
      via: "service_worker registration"
      pattern: "service_worker.*background"
---

<objective>
Create the Chrome Extension Manifest V3 scaffolding, storage abstraction layer, and error handling infrastructure that all subsequent plans depend on.

Purpose: This is the absolute foundation -- manifest configuration, file structure, storage patterns, and error handling must exist before service worker lifecycle management or onboarding UI can be built.
Output: A loadable Chrome extension with storage utilities and error handling ready for use by all other modules.
</objective>

<execution_context>
@/Users/udirno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/udirno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Manifest V3 scaffolding and project structure</name>
  <files>
    manifest.json
    src/background.js
    src/popup.html
    src/popup.css
    icons/icon16.png
    icons/icon48.png
    icons/icon128.png
  </files>
  <action>
Create the Chrome Extension Manifest V3 configuration and basic file structure.

**manifest.json** must include:
- `manifest_version: 3`
- `name: "JobDigest"`
- `version: "0.1.0"`
- `description: "AI-powered job search assistant that auto-fetches, scores, and tracks jobs"`
- `permissions`: `["storage", "unlimitedStorage", "alarms"]` (ERROR-07 requires unlimitedStorage)
- `host_permissions`: `["https://api.anthropic.com/*", "https://api.adzuna.com/*", "https://jsearch.p.rapidapi.com/*"]` (CORS permissions for all three APIs)
- `background`: `{ "service_worker": "src/background.js", "type": "module" }` (use ES modules for clean imports)
- `action`: `{ "default_popup": "src/popup.html", "default_icon": { "16": "icons/icon16.png", "48": "icons/icon48.png", "128": "icons/icon128.png" } }`
- `icons`: same icon references at 16, 48, 128

**src/background.js** -- minimal stub that imports storage and errors modules, logs "JobDigest service worker started" on load. Use ES module imports (`import`).

**src/popup.html** -- minimal HTML shell with `<!DOCTYPE html>`, charset utf-8, viewport meta, link to popup.css, title "JobDigest". Include a single `<div id="app">Loading...</div>` container. Script tag with `type="module"` pointing to `src/popup.js` (will be created in Plan 03).

**src/popup.css** -- basic reset styles (box-sizing, margin/padding zero) and root CSS variables for the design system: `--bg-primary: #1a1a1a` (black background), `--bg-secondary: #2a2a2a`, `--accent: #c9a96e` (sand brown), `--accent-hover: #d4b87a`, `--text-primary: #e8e8e8`, `--text-secondary: #999`, `--error: #e74c3c`, `--success: #27ae60`. Body uses bg-primary and text-primary. Set `width: 400px; min-height: 500px` on body for popup dimensions.

**icons/** -- Generate simple placeholder PNG icons at 16x16, 48x48, and 128x128. Use a solid colored square (the accent color #c9a96e) as a placeholder. You can create these programmatically using an HTML canvas approach or a simple script. If canvas/image generation is not feasible, create minimal valid PNG files (even 1-color solid PNGs are fine as placeholders).
  </action>
  <verify>
Load the extension in Chrome by navigating to `chrome://extensions`, enabling Developer Mode, and clicking "Load unpacked" pointing to the project root. The extension should appear in the extensions list without errors. Verify by checking: no red error badge appears on the extension card.

Alternatively, verify the manifest is valid JSON: `node -e "JSON.parse(require('fs').readFileSync('manifest.json','utf8')); console.log('manifest OK')"` from the project root.
  </verify>
  <done>
manifest.json is valid Manifest V3 with correct permissions (storage, unlimitedStorage, alarms) and host_permissions for all three APIs. Service worker registered. Popup HTML shell exists with design system CSS variables. Icon placeholders exist at all three sizes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build storage abstraction layer</name>
  <files>src/storage.js</files>
  <action>
Create a storage abstraction layer wrapping `chrome.storage.local` with typed, ergonomic methods.

**Design decisions (Claude's discretion per CONTEXT.md):**
- Metadata (resume, settings, API keys) stored under separate top-level keys: `settings`, `resume`, `apiKeys`
- Generated content (cover letters, messages) embedded in job objects under `generated` key
- Job data stored as object map per user decision: `{ jobs: { jobId1: {...}, jobId2: {...} } }`

**Storage keys and structure:**

```javascript
// Storage key constants
const STORAGE_KEYS = {
  API_KEYS: 'apiKeys',       // { claude: string, adzuna: { appId: string, appKey: string }, jsearch: string }
  SETTINGS: 'settings',       // { searchKeywords: [], location: '', ... }
  RESUME: 'resume',           // { text: string, fileName: string, uploadedAt: string }
  JOBS: 'jobs',               // { [jobId]: { ...jobData, generated?: { coverLetter, recruiterMsg } } }
  DAILY_STATS: 'dailyStats',  // { date: 'YYYY-MM-DD', jobsFetched: number }
  ONBOARDING: 'onboarding',   // { completed: boolean, completedAt: string }
  BATCH_PROGRESS: 'batchProgress' // { inProgress: boolean, lastBatchIndex: number, totalBatches: number }
};
```

**Exported `storage` object with methods:**

1. `storage.get(key)` -- Wraps `chrome.storage.local.get(key)`, returns promise resolving to the value (not the wrapper object). Returns `null` if key not found.
2. `storage.set(key, value)` -- Wraps `chrome.storage.local.set({[key]: value})`, returns promise.
3. `storage.getApiKeys()` -- Returns API keys object, defaults to `{ claude: '', adzuna: { appId: '', appKey: '' }, jsearch: '' }` if not set.
4. `storage.setApiKeys(keys)` -- Saves API keys, merges with existing (partial update safe).
5. `storage.getJobs()` -- Returns jobs object map, defaults to `{}`.
6. `storage.saveJob(jobId, jobData)` -- Saves single job into the jobs map (read-modify-write pattern).
7. `storage.saveJobs(jobsMap)` -- Merges multiple jobs into existing map (for batch saves per ERROR-04).
8. `storage.getDailyStats()` -- Returns today's stats, auto-resets if date changed (for CONFIG-10 daily cap).
9. `storage.incrementDailyCount(count)` -- Increments today's fetch count.
10. `storage.getOnboarding()` -- Returns onboarding status.
11. `storage.setOnboarding(status)` -- Saves onboarding status.
12. `storage.getBatchProgress()` -- Returns batch progress for service worker restart recovery (ERROR-04).
13. `storage.setBatchProgress(progress)` -- Saves batch progress.
14. `storage.clearBatchProgress()` -- Clears batch progress on completion.

All methods use async/await. All methods handle chrome.runtime.lastError gracefully. Export STORAGE_KEYS constant and storage object.
  </action>
  <verify>
Create a quick smoke test by adding a temporary test in background.js:

```javascript
import { storage, STORAGE_KEYS } from './storage.js';
// Test round-trip
async function testStorage() {
  await storage.set(STORAGE_KEYS.ONBOARDING, { completed: false });
  const result = await storage.getOnboarding();
  console.log('Storage test:', result.completed === false ? 'PASS' : 'FAIL');
}
testStorage();
```

Load extension, open service worker console (click "Inspect views: service worker" on chrome://extensions), verify "Storage test: PASS" appears. Remove test code after verification.
  </verify>
  <done>
storage.js exports STORAGE_KEYS and storage object with all 14 methods. Each method wraps chrome.storage.local correctly with async/await. getDailyStats auto-resets when date changes. All methods handle errors gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build error handling infrastructure</name>
  <files>src/errors.js</files>
  <action>
Create error handling utilities covering API failures, exponential backoff retry, and user-friendly error messages.

**ApiError class:**
```javascript
class ApiError extends Error {
  constructor(message, { status, service, retryable, originalError } = {}) {
    super(message);
    this.name = 'ApiError';
    this.status = status;         // HTTP status code
    this.service = service;       // 'claude' | 'adzuna' | 'jsearch'
    this.retryable = retryable;   // boolean - should we retry?
    this.originalError = originalError;
    this.timestamp = new Date().toISOString();
  }
}
```

**retryWithBackoff(fn, options):**
- `fn`: async function to retry
- `options`: `{ maxRetries: 3, baseDelay: 1000, maxDelay: 30000, onRetry: null }`
- Implements exponential backoff: delay = min(baseDelay * 2^attempt, maxDelay) + random jitter (0-500ms)
- On 429 (rate limit): respect `Retry-After` header if available, otherwise use exponential backoff (ERROR-02)
- On 5xx: retry with backoff
- On 4xx (except 429): do NOT retry (client error, won't improve)
- On network error: retry with backoff
- Returns the successful result or throws the last error after exhausting retries
- Calls `onRetry(attempt, delay, error)` callback if provided (for logging/UI updates)

**getUserMessage(error):**
Maps technical errors to user-friendly strings (ERROR-01):
- 401/403: "Invalid API key. Please check your {service} API key in Settings."
- 429: "Rate limit reached for {service}. Will retry automatically."
- 500-599: "{service} is temporarily unavailable. Please try again later."
- Network error: "Unable to connect. Please check your internet connection."
- Unknown: "Something went wrong. Please try again."

**createApiError(response, service):**
Factory function that creates ApiError from a fetch Response object:
- Reads response status
- Sets retryable based on status code rules above
- Sets service name
- Attempts to parse response body for error message

Export: `ApiError`, `retryWithBackoff`, `getUserMessage`, `createApiError`.
  </action>
  <verify>
Add a temporary test in background.js:

```javascript
import { retryWithBackoff, ApiError, getUserMessage } from './errors.js';

async function testErrors() {
  // Test 1: retryWithBackoff succeeds on first try
  const result = await retryWithBackoff(async () => 'ok');
  console.log('Backoff immediate:', result === 'ok' ? 'PASS' : 'FAIL');

  // Test 2: getUserMessage for 401
  const err = new ApiError('Unauthorized', { status: 401, service: 'claude' });
  const msg = getUserMessage(err);
  console.log('User message:', msg.includes('API key') ? 'PASS' : 'FAIL');

  // Test 3: retryWithBackoff retries then succeeds
  let attempt = 0;
  const result2 = await retryWithBackoff(async () => {
    attempt++;
    if (attempt < 3) throw new ApiError('fail', { status: 500, retryable: true });
    return 'recovered';
  }, { maxRetries: 3, baseDelay: 100 });
  console.log('Backoff retry:', result2 === 'recovered' ? 'PASS' : 'FAIL');
}
testErrors();
```

Load extension, check service worker console for three PASS lines. Remove test code after verification.
  </verify>
  <done>
errors.js exports ApiError class, retryWithBackoff with exponential backoff + jitter + Retry-After header support, getUserMessage mapping errors to friendly strings, and createApiError factory. Backoff correctly skips retries on 4xx (except 429), retries on 429/5xx/network errors.
  </done>
</task>

</tasks>

<verification>
1. Run `node -e "JSON.parse(require('fs').readFileSync('manifest.json','utf8')); console.log('Valid JSON')"` from project root -- confirms manifest is valid
2. Load extension in Chrome via chrome://extensions (Developer Mode > Load Unpacked)
3. No error badge on extension card
4. Click "Inspect views: service worker" -- console shows "JobDigest service worker started"
5. Storage and error test logs show all PASS (then remove test code)
</verification>

<success_criteria>
- manifest.json is valid Manifest V3 with permissions [storage, unlimitedStorage, alarms] and host_permissions for all three APIs
- src/background.js loads as ES module service worker without errors
- src/storage.js provides full CRUD abstraction over chrome.storage.local with all 14 methods
- src/errors.js provides ApiError, retryWithBackoff (exponential + jitter + Retry-After), getUserMessage, createApiError
- src/popup.html and popup.css establish the design system shell
- Extension loads in Chrome without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md`
</output>
