---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/background.js
  - src/keep-alive.js
autonomous: true

must_haves:
  truths:
    - "Service worker recovers state after termination and restart"
    - "Long API operations keep the service worker alive"
    - "Batch progress is saved after each batch so work resumes on restart"
    - "Daily job cap of 100 is enforced across service worker restarts"
  artifacts:
    - path: "src/keep-alive.js"
      provides: "Keep-alive utilities for service worker during long operations"
      exports: ["keepAlive", "stopKeepAlive"]
      min_lines: 20
    - path: "src/background.js"
      provides: "Full service worker with lifecycle management, state recovery, and daily cap"
      min_lines: 80
  key_links:
    - from: "src/background.js"
      to: "src/storage.js"
      via: "imports storage for state persistence"
      pattern: "import.*storage"
    - from: "src/background.js"
      to: "src/keep-alive.js"
      via: "imports keep-alive for long operations"
      pattern: "import.*keepAlive|import.*keep-alive"
    - from: "src/background.js"
      to: "chrome.alarms"
      via: "alarm listener for daily scheduling"
      pattern: "chrome\\.alarms\\.onAlarm"
---

<objective>
Implement service worker lifecycle management: keep-alive pattern during long API operations, state persistence and recovery on restart, batch progress checkpointing, and daily job cap enforcement.

Purpose: Chrome Manifest V3 service workers terminate after 30 seconds of inactivity. Without keep-alive and state recovery, long operations (job fetching, AI scoring) will fail silently. This is the reliability backbone of the extension.
Output: A resilient service worker that survives termination and resumes work, with keep-alive utilities for long operations.
</objective>

<execution_context>
@/Users/udirno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/udirno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create keep-alive utilities and batch progress infrastructure</name>
  <files>src/keep-alive.js</files>
  <action>
Create keep-alive utilities that prevent the Manifest V3 service worker from terminating during long-running operations (ERROR-03).

**keepAlive module:**

`keepAlive.start(tag)`:
- Uses chrome.alarms API to create a recurring alarm every 25 seconds (service worker times out at 30s)
- Alarm name: `keepalive-{tag}` (tag identifies the operation, e.g., "job-fetch", "ai-scoring")
- Also sets up a periodic self-ping using `setTimeout` as a secondary keep-alive mechanism: every 20 seconds, call `chrome.runtime.getPlatformInfo()` (a lightweight API call that resets the idle timer)
- Stores the interval ID so it can be cleaned up
- Returns a cleanup function

`keepAlive.stop(tag)`:
- Clears the alarm: `chrome.alarms.clear('keepalive-{tag}')`
- Clears the setTimeout interval
- Logs "Keep-alive stopped for {tag}"

`keepAlive.withKeepAlive(tag, asyncFn)`:
- Convenience wrapper: starts keep-alive, runs asyncFn, stops keep-alive in finally block
- Returns the result of asyncFn
- If asyncFn throws, keep-alive is still stopped (finally block) and error is re-thrown

**Implementation notes:**
- The chrome.alarms approach is the recommended Manifest V3 pattern for keeping service workers alive
- The setTimeout self-ping is a backup -- some Chrome versions may not count alarm handlers as "activity"
- Both mechanisms together provide robust keep-alive coverage

Export: `keepAlive` object with `start`, `stop`, `withKeepAlive` methods.
  </action>
  <verify>
Add temporary test in background.js:

```javascript
import { keepAlive } from './keep-alive.js';

async function testKeepAlive() {
  const cleanup = keepAlive.start('test');
  // Check alarm was created
  const alarm = await chrome.alarms.get('keepalive-test');
  console.log('Keep-alive alarm:', alarm ? 'PASS' : 'FAIL');

  keepAlive.stop('test');
  const alarmAfter = await chrome.alarms.get('keepalive-test');
  console.log('Keep-alive stopped:', !alarmAfter ? 'PASS' : 'FAIL');

  // Test withKeepAlive wrapper
  const result = await keepAlive.withKeepAlive('test2', async () => {
    return 'done';
  });
  console.log('withKeepAlive:', result === 'done' ? 'PASS' : 'FAIL');
  const alarmAfter2 = await chrome.alarms.get('keepalive-test2');
  console.log('Cleaned up:', !alarmAfter2 ? 'PASS' : 'FAIL');
}
testKeepAlive();
```

Load extension, check service worker console for four PASS lines. Remove test code after.
  </verify>
  <done>
keep-alive.js exports keepAlive object with start/stop/withKeepAlive methods. start() creates recurring alarm every 25s and setTimeout self-ping every 20s. stop() clears both. withKeepAlive() wraps async operations with automatic cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement full service worker lifecycle management</name>
  <files>src/background.js</files>
  <action>
Replace the stub background.js with a full service worker implementing lifecycle management, state recovery, daily cap enforcement, and message routing.

**On install (`chrome.runtime.onInstalled`):**
- Log "JobDigest installed/updated"
- If reason is "install": initialize default storage values (empty API keys, onboarding not completed, daily stats for today with 0 count)
- Create daily alarm: `chrome.alarms.create('daily-job-fetch', { periodInMinutes: 1440 })` -- fires every 24 hours. The actual 6 AM PST scheduling will be refined in Phase 3; for now, establish the alarm pattern.

**On startup (`chrome.runtime.onStartup`):**
- Log "JobDigest service worker started"
- Check if batch progress exists in storage (ERROR-04): if `batchProgress.inProgress === true`, log "Recovering batch progress from previous session" (actual recovery logic will be added in Phase 3 when batch processing is implemented)
- Verify daily alarm exists: `chrome.alarms.get('daily-job-fetch')` -- if missing, recreate it (handles cases where Chrome clears alarms)

**On alarm (`chrome.alarms.onAlarm`):**
- Route alarm by name:
  - `'daily-job-fetch'`: Log "Daily job fetch alarm fired" (actual fetch will be wired in Phase 3)
  - `'keepalive-*'`: Ignore (these are keep-alive pings, handled by keep-alive.js)

**On message (`chrome.runtime.onMessage`):**
- Set up message router for popup/onboarding communication:
  - `{ type: 'GET_ONBOARDING_STATUS' }`: Return onboarding status from storage
  - `{ type: 'CHECK_DAILY_CAP' }`: Return `{ remaining: 100 - dailyStats.jobsFetched, limit: 100 }` (CONFIG-10)
  - `{ type: 'TEST_API_CONNECTION', service, credentials }`: Perform a lightweight API test call:
    - Claude: `POST https://api.anthropic.com/v1/messages` with a tiny prompt ("Hi"), `x-api-key` header, model `claude-3-5-sonnet-20241022`, max_tokens 1. Check for 200 response.
    - Adzuna: `GET https://api.adzuna.com/v1/api/jobs/us/search/1?app_id={appId}&app_key={appKey}&results_per_page=1`. Check for 200 response.
    - JSearch: `GET https://jsearch.p.rapidapi.com/search?query=test&num_pages=1` with `X-RapidAPI-Key` header. Check for 200 response.
    - Return `{ success: true }` or `{ success: false, message: getUserMessage(error) }`
    - Wrap each test call in try/catch, use createApiError for failures
  - Unknown message types: Log warning, return `{ error: 'Unknown message type' }`

**Daily cap helper function `checkDailyCap()`:**
- Get daily stats from storage
- If `dailyStats.jobsFetched >= 100`, return `{ allowed: false, remaining: 0 }`
- Otherwise return `{ allowed: true, remaining: 100 - dailyStats.jobsFetched }`

**Imports:** Import storage/STORAGE_KEYS from storage.js, keepAlive from keep-alive.js, error utilities from errors.js.
  </action>
  <verify>
Load extension in Chrome. Test the following:

1. Check service worker console: "JobDigest installed/updated" should appear
2. Run in service worker console: `chrome.alarms.get('daily-job-fetch', a => console.log('Alarm:', a))` -- should show the alarm
3. Run in popup console or service worker console:
   ```javascript
   chrome.runtime.sendMessage({ type: 'GET_ONBOARDING_STATUS' }, r => console.log('Onboarding:', r));
   chrome.runtime.sendMessage({ type: 'CHECK_DAILY_CAP' }, r => console.log('Cap:', r));
   ```
   Both should return valid objects (onboarding: {completed: false}, cap: {remaining: 100, limit: 100}).
4. Terminate service worker (click "Service worker" link then "Terminate" on chrome://extensions) and reopen popup -- service worker should restart and log startup messages.
  </verify>
  <done>
background.js handles onInstalled (initializes storage, creates daily alarm), onStartup (checks batch progress recovery, verifies alarm), onAlarm (routes by alarm name), onMessage (handles GET_ONBOARDING_STATUS, CHECK_DAILY_CAP, TEST_API_CONNECTION). Daily cap enforces 100 jobs/day limit. Service worker recovers gracefully after termination.
  </done>
</task>

</tasks>

<verification>
1. Extension loads without errors after changes
2. Service worker console shows install/startup logs
3. Daily alarm exists and persists across service worker restarts
4. Message handler responds correctly to GET_ONBOARDING_STATUS, CHECK_DAILY_CAP, and TEST_API_CONNECTION
5. Keep-alive utilities create and clean up alarms correctly
6. Service worker survives termination + restart and recovers state
</verification>

<success_criteria>
- keep-alive.js provides reliable keep-alive for operations up to 5 minutes (alarm + setTimeout dual mechanism)
- background.js handles full lifecycle: install, startup, alarm routing, message routing
- Daily cap of 100 jobs/day is enforced and resets daily (CONFIG-10)
- Batch progress checkpointing reads/writes correctly for future recovery (ERROR-04)
- TEST_API_CONNECTION tests all three APIs with correct endpoints and headers
- Service worker restarts cleanly after termination
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
