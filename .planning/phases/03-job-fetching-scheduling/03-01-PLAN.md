---
phase: 03-job-fetching-scheduling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/adzuna.js
  - src/api/jsearch.js
  - src/storage.js
autonomous: true

must_haves:
  truths:
    - "Adzuna API client fetches jobs with proper authentication (app_id, app_key query params)"
    - "JSearch API client fetches jobs with proper authentication (X-RapidAPI-Key header)"
    - "Both API clients return normalized job objects with consistent schema"
    - "Storage has keys for settings, fetch history, and adaptive metrics"
    - "Both clients use existing retryWithBackoff for error handling"
  artifacts:
    - path: "src/api/adzuna.js"
      provides: "Adzuna API client with fetchAdzunaJobs function"
      exports: ["fetchAdzunaJobs"]
    - path: "src/api/jsearch.js"
      provides: "JSearch API client with fetchJSearchJobs function"
      exports: ["fetchJSearchJobs"]
    - path: "src/storage.js"
      provides: "Extended storage with SETTINGS, FETCH_HISTORY, ADAPTIVE_METRICS keys and helper methods"
      contains: "FETCH_HISTORY"
  key_links:
    - from: "src/api/adzuna.js"
      to: "src/errors.js"
      via: "import retryWithBackoff, createApiError"
      pattern: "import.*retryWithBackoff.*errors"
    - from: "src/api/jsearch.js"
      to: "src/errors.js"
      via: "import retryWithBackoff, createApiError"
      pattern: "import.*retryWithBackoff.*errors"
    - from: "src/api/adzuna.js"
      to: "src/storage.js"
      via: "import storage for API keys"
      pattern: "import.*storage"
    - from: "src/api/jsearch.js"
      to: "src/storage.js"
      via: "import storage for API keys"
      pattern: "import.*storage"
---

<objective>
Create API client modules for Adzuna and JSearch that fetch jobs and return normalized job objects, plus extend storage.js with new keys needed for Phase 3 (settings, fetch history, adaptive metrics).

Purpose: These API clients are the data acquisition layer. The job-fetcher orchestrator (Plan 02) will call these clients to get jobs. Storage extensions provide the persistence schema for scheduling preferences, fetch history tracking, and adaptive distribution metrics.

Output: Two new API client files (`src/api/adzuna.js`, `src/api/jsearch.js`) and updated `src/storage.js` with new storage keys and helper methods.
</objective>

<execution_context>
@/Users/udirno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/udirno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-job-fetching-scheduling/03-RESEARCH.md
@src/storage.js
@src/errors.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend storage.js with Phase 3 storage keys and helpers</name>
  <files>src/storage.js</files>
  <action>
Add new storage keys to STORAGE_KEYS constant:
- `SETTINGS: 'settings'` — already declared as comment, formalize with helpers. Schema: `{ fetchHour: number (0-23, default 6), fetchMinute: number (0-59, default 0), timezone: string (IANA, auto-detected), searchKeywords: string[], location: string, salaryMin: number|null, datePosted: string ('all'|'today'|'3days'|'week'|'month'), employmentType: string ('FULLTIME'|'PARTTIME'|'CONTRACTOR'|'FULLTIME,PARTTIME'), remoteOnly: boolean }`
- `FETCH_HISTORY: 'fetchHistory'` — Schema: array of `{ date: string (YYYY-MM-DD), startedAt: string (ISO), completedAt: string (ISO)|null, status: 'success'|'partial'|'failed', jobsFetched: number, adzunaCount: number, jsearchCount: number, errors: string[] }`, keep last 7 entries
- `ADAPTIVE_METRICS: 'adaptiveMetrics'` — Schema: `{ adzuna: { recentWindow: [{ date, avgScore, highValueCount, jobCount }] }, jsearch: { recentWindow: [{ date, avgScore, highValueCount, jobCount }] }, lastCalibration: string (ISO) }`

Add helper methods to the storage object:
- `async getSettings()` — returns settings with defaults: `{ fetchHour: 6, fetchMinute: 0, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, searchKeywords: [], location: '', salaryMin: null, datePosted: 'all', employmentType: 'FULLTIME', remoteOnly: false }`
- `async setSettings(settings)` — merges with existing settings (partial update safe, same pattern as setApiKeys)
- `async getFetchHistory()` — returns array, default empty []
- `async addFetchHistoryEntry(entry)` — appends entry, trims to last 7 entries, saves
- `async getAdaptiveMetrics()` — returns metrics with defaults: `{ adzuna: { recentWindow: [] }, jsearch: { recentWindow: [] }, lastCalibration: null }`
- `async setAdaptiveMetrics(metrics)` — saves metrics object

Keep existing methods unchanged. Follow the exact same code style as existing helpers (JSDoc comments, try/catch wrapping pattern).
  </action>
  <verify>
Read the file and confirm:
1. All three new STORAGE_KEYS are present
2. All six new helper methods exist with JSDoc comments
3. getSettings returns proper defaults including auto-detected timezone
4. addFetchHistoryEntry trims to 7 entries
5. Existing methods (getJobs, saveJob, getDailyStats, etc.) are unchanged
  </verify>
  <done>storage.js has SETTINGS, FETCH_HISTORY, ADAPTIVE_METRICS keys with 6 new helper methods, all existing functionality preserved</done>
</task>

<task type="auto">
  <name>Task 2: Create Adzuna API client</name>
  <files>src/api/adzuna.js</files>
  <action>
Create `src/api/` directory and `src/api/adzuna.js`.

Import `{ storage }` from `'../storage.js'` and `{ retryWithBackoff, createApiError }` from `'../errors.js'`.

Export async function `fetchAdzunaJobs(count, searchParams = {})`:

1. Get API keys: `const apiKeys = await storage.getApiKeys()`
2. Get search settings: `const settings = await storage.getSettings()`
3. Destructure searchParams with settings fallbacks:
   - `query` defaults to `settings.searchKeywords.join(' ')` or `'software engineer'` if empty
   - `location` defaults to `settings.location` or `''`
   - `salaryMin` defaults to `settings.salaryMin` or `null`
   - `resultsPerPage` defaults to `Math.min(count, 50)` (Adzuna max per page is 50)

4. Build URL: `https://api.adzuna.com/v1/api/jobs/us/search/1`
   - Set query params: `app_id`, `app_key`, `results_per_page`, `what` (query), `content-type=application/json`
   - Only add `where` if location is non-empty
   - Only add `salary_min` if salaryMin is not null
   - Sort by `date` to get freshest jobs

5. Wrap fetch in `retryWithBackoff`:
   - Use `createApiError(res, 'adzuna')` for non-ok responses
   - Parse JSON response

6. Handle pagination: If `count > 50`, make multiple requests incrementing page number. Collect all results.

7. Transform response to normalized job format. Map each `job` in `response.results`:
```javascript
{
  jobId: `adzuna-${job.id}`,
  source: 'adzuna',
  title: job.title,
  company: job.company?.display_name || 'Unknown',
  location: job.location?.display_name || '',
  salary: {
    min: job.salary_min || null,
    max: job.salary_max || null,
    predicted: job.salary_is_predicted || false
  },
  description: job.description || '',
  url: job.redirect_url,
  postedAt: job.created,
  contractType: job.contract_type || null,
  fetchedAt: new Date().toISOString(),
  status: 'new',
  score: null,
  scoreReasoning: null
}
```

8. Return array of normalized jobs, sliced to `count`.

Handle edge cases:
- If API keys are missing (empty appId or appKey), throw an ApiError with service: 'adzuna', status: null, retryable: false, message: 'Adzuna API keys not configured'
- If response.results is undefined/null, return empty array
- Log fetch count: `console.log('Adzuna: fetched ${results.length} jobs')`
  </action>
  <verify>
Read the file and confirm:
1. Imports from ../storage.js and ../errors.js use correct relative paths
2. fetchAdzunaJobs is exported as named export
3. URL construction uses proper Adzuna API endpoint with query params
4. retryWithBackoff wraps the fetch call
5. Response is transformed to normalized schema with jobId prefix 'adzuna-'
6. Missing API keys throw ApiError (not generic Error)
7. Pagination logic handles count > 50
  </verify>
  <done>src/api/adzuna.js exports fetchAdzunaJobs that fetches from Adzuna API, handles pagination, uses retry logic, and returns normalized job objects</done>
</task>

<task type="auto">
  <name>Task 3: Create JSearch API client</name>
  <files>src/api/jsearch.js</files>
  <action>
Create `src/api/jsearch.js`.

Import `{ storage }` from `'../storage.js'` and `{ retryWithBackoff, createApiError }` from `'../errors.js'`.

Export async function `fetchJSearchJobs(count, searchParams = {})`:

1. Get API keys: `const apiKeys = await storage.getApiKeys()`
2. Get search settings: `const settings = await storage.getSettings()`
3. Destructure searchParams with settings fallbacks:
   - `query` defaults to building a combined query string: `settings.searchKeywords.join(' ')` + ` in ${settings.location}` if location exists, or `'software engineer'` if keywords empty
   - `datePosted` defaults to `settings.datePosted` or `'all'`
   - `remoteOnly` defaults to `settings.remoteOnly` or `false`
   - `employmentType` defaults to `settings.employmentType` or `'FULLTIME'`
   - `numPages` calculated as `Math.ceil(count / 10)` (JSearch returns ~10 per page)

4. Build URL: `https://jsearch.p.rapidapi.com/search`
   - Set query params: `query`, `page=1`, `num_pages` (calculate based on count)
   - Set `date_posted` if not 'all'
   - Set `remote_jobs_only=true` if remoteOnly
   - Set `employment_types` if provided

5. Headers: `{ 'X-RapidAPI-Key': apiKey, 'X-RapidAPI-Host': 'jsearch.p.rapidapi.com' }`

6. Wrap fetch in `retryWithBackoff`:
   - Use `createApiError(res, 'jsearch')` for non-ok responses
   - Parse JSON response

7. Transform response to normalized job format. Map each `job` in `response.data`:
```javascript
{
  jobId: `jsearch-${job.job_id}`,
  source: 'jsearch',
  title: job.job_title,
  company: job.employer_name || 'Unknown',
  location: (job.job_city && job.job_state)
    ? `${job.job_city}, ${job.job_state}`
    : (job.job_country || ''),
  salary: {
    min: job.job_min_salary || null,
    max: job.job_max_salary || null,
    predicted: false
  },
  description: job.job_description || '',
  url: job.job_apply_link || job.job_google_link,
  postedAt: job.job_posted_at_datetime_utc,
  employmentType: job.job_employment_type || null,
  isRemote: job.job_is_remote || false,
  fetchedAt: new Date().toISOString(),
  status: 'new',
  score: null,
  scoreReasoning: null
}
```

8. Return array of normalized jobs, sliced to `count`.

Handle edge cases:
- If API key is missing (empty string), throw an ApiError with service: 'jsearch', status: null, retryable: false, message: 'JSearch API key not configured'
- If response.data is undefined/null, return empty array
- Log fetch count: `console.log('JSearch: fetched ${results.length} jobs')`
  </action>
  <verify>
Read the file and confirm:
1. Imports from ../storage.js and ../errors.js use correct relative paths
2. fetchJSearchJobs is exported as named export
3. URL uses jsearch.p.rapidapi.com with proper headers (X-RapidAPI-Key, X-RapidAPI-Host)
4. retryWithBackoff wraps the fetch call
5. Response is transformed to normalized schema with jobId prefix 'jsearch-'
6. Missing API key throws ApiError
7. Query string combines keywords + location per JSearch format
  </verify>
  <done>src/api/jsearch.js exports fetchJSearchJobs that fetches from JSearch/RapidAPI, uses retry logic, and returns normalized job objects with same schema as Adzuna client</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `src/storage.js` has SETTINGS, FETCH_HISTORY, ADAPTIVE_METRICS keys with helper methods
2. `src/api/adzuna.js` exists and exports `fetchAdzunaJobs`
3. `src/api/jsearch.js` exists and exports `fetchJSearchJobs`
4. Both API clients import from `../storage.js` and `../errors.js`
5. Both clients return jobs in identical normalized schema (jobId, source, title, company, location, salary, description, url, postedAt, fetchedAt, status, score, scoreReasoning)
6. Both clients use retryWithBackoff for API calls
7. No existing functionality in storage.js broken
</verification>

<success_criteria>
- Two API client modules exist that can independently fetch jobs from their respective APIs
- Storage schema is extended with settings, fetch history, and adaptive metrics
- Both clients return normalized job objects suitable for storage via storage.saveJobs()
- Error handling uses existing Phase 1 infrastructure (retryWithBackoff, createApiError, ApiError)
</success_criteria>

<output>
After completion, create `.planning/phases/03-job-fetching-scheduling/03-01-SUMMARY.md`
</output>
