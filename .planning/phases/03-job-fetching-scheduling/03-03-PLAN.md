---
phase: 03-job-fetching-scheduling
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/background.js
autonomous: true

must_haves:
  truths:
    - "Daily alarm fires and triggers job fetch automatically"
    - "Missed alarms are handled with smart catch-up (< 2 hours delay AND no fetch today)"
    - "Alarm is verified and recreated on browser startup if missing"
    - "Service worker restart recovers in-progress fetch from last checkpoint"
    - "Manual fetch can be triggered via message from popup"
    - "Fetch status and progress are available via message passing"
  artifacts:
    - path: "src/background.js"
      provides: "Full service worker integration with fetch pipeline, alarm handling, batch recovery, and message routing"
      contains: "runJobFetch"
  key_links:
    - from: "src/background.js"
      to: "src/job-fetcher.js"
      via: "import runJobFetch, resumeJobFetch"
      pattern: "import.*runJobFetch.*job-fetcher"
    - from: "src/background.js"
      to: "src/scheduler.js"
      via: "import scheduleDailyFetch, verifyAlarmExists"
      pattern: "import.*scheduleDailyFetch.*scheduler"
    - from: "src/background.js"
      to: "chrome.alarms.onAlarm"
      via: "alarm listener triggers fetch"
      pattern: "alarm\\.name === 'daily-job-fetch'"
---

<objective>
Wire the fetch pipeline into the service worker's lifecycle. Update background.js to: trigger job fetches from daily alarms with missed-alarm handling, recover in-progress fetches on startup, schedule alarms using user's preferred time, and add message handlers for manual fetch trigger and fetch status queries.

Purpose: This is the integration layer that connects the fetch engine (Plan 02) to Chrome's service worker lifecycle. Without this wiring, the fetch pipeline exists but never runs.

Output: Updated `src/background.js` with alarm-triggered fetching, startup recovery, missed alarm handling, and new message handlers (TRIGGER_FETCH, GET_FETCH_STATUS, GET_NEXT_FETCH_TIME).
</objective>

<execution_context>
@/Users/udirno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/udirno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-job-fetching-scheduling/03-RESEARCH.md
@src/background.js
@src/storage.js
@src/keep-alive.js
@.planning/phases/03-job-fetching-scheduling/03-01-SUMMARY.md
@.planning/phases/03-job-fetching-scheduling/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update background.js imports and onInstalled handler</name>
  <files>src/background.js</files>
  <action>
Read the current `src/background.js` carefully. Make the following targeted changes:

**1. Add new imports at the top (after existing imports):**
```javascript
import { scheduleDailyFetch, verifyAlarmExists, getNextFetchTime } from './scheduler.js';
import { runJobFetch, resumeJobFetch } from './job-fetcher.js';
```

**2. Update onInstalled handler:**
Replace the existing alarm creation block:
```javascript
// OLD:
chrome.alarms.create('daily-job-fetch', {
  periodInMinutes: 1440
});
```
With:
```javascript
// Schedule daily fetch with user's preferred time (defaults to 6:00 AM local)
await scheduleDailyFetch();
```

Also add default settings initialization on first install (inside the `if (details.reason === 'install')` block, after existing defaults):
```javascript
// Initialize default settings
const defaultTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
await storage.set(STORAGE_KEYS.SETTINGS, {
  fetchHour: 6,
  fetchMinute: 0,
  timezone: defaultTimezone,
  searchKeywords: [],
  location: '',
  salaryMin: null,
  datePosted: 'all',
  employmentType: 'FULLTIME',
  remoteOnly: false
});
```

**3. Update onStartup handler:**
Replace the existing startup handler with:
```javascript
chrome.runtime.onStartup.addListener(async () => {
  console.log('JobDigest service worker started');

  // Verify daily alarm exists (Chrome may clear alarms on restart)
  const alarmStatus = await verifyAlarmExists();
  if (!alarmStatus.exists) {
    console.log('Daily alarm was recreated');
  }

  // Check for in-progress batch recovery
  const batchProgress = await storage.getBatchProgress();
  if (batchProgress.inProgress === true) {
    console.log('Recovering in-progress fetch from stage:', batchProgress.stage || 'unknown');
    try {
      const result = await resumeJobFetch();
      console.log('Fetch recovery complete:', result);
    } catch (error) {
      console.error('Fetch recovery failed:', error);
      // Clear stuck progress to prevent infinite recovery loop
      await storage.clearBatchProgress();
    }
  }
});
```

**4. Update alarm listener:**
Replace the existing alarm listener with:
```javascript
chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name === 'daily-job-fetch') {
    console.log('Daily job fetch alarm fired');

    // Smart catch-up: detect missed alarms after device sleep
    const now = Date.now();
    const delayMinutes = (now - alarm.scheduledTime) / 1000 / 60;

    if (delayMinutes > 120) {
      // Missed by more than 2 hours (likely device was asleep)
      console.warn(`Alarm missed by ${delayMinutes.toFixed(0)} minutes`);

      // Skip if already fetched today
      const dailyStats = await storage.getDailyStats();
      if (dailyStats.jobsFetched > 0) {
        console.log('Already fetched jobs today, skipping catch-up fetch');
        return;
      }
      console.log('No jobs fetched today, proceeding with catch-up fetch');
    }

    // Run the fetch pipeline
    try {
      const result = await runJobFetch({ manual: false });
      console.log('Daily fetch complete:', result);
    } catch (error) {
      console.error('Daily fetch failed:', error);
    }
  } else if (alarm.name.startsWith('keepalive-')) {
    // Ignore keep-alive pings (handled by keep-alive.js)
  } else {
    console.warn('Unknown alarm:', alarm.name);
  }
});
```

**5. Add new message handlers to the handleMessage switch:**

Add these cases to the existing switch statement:

```javascript
case 'TRIGGER_FETCH': {
  // Manual fetch triggered by user
  console.log('Manual fetch triggered by user');
  const result = await runJobFetch({ manual: true });
  return result;
}

case 'GET_FETCH_STATUS': {
  // Return current fetch state for UI
  const batchProgress = await storage.getBatchProgress();
  const dailyStats = await storage.getDailyStats();
  const fetchHistory = await storage.getFetchHistory();
  const nextFetch = await getNextFetchTime();

  return {
    inProgress: batchProgress.inProgress,
    currentStage: batchProgress.stage || null,
    dailyStats: {
      jobsFetched: dailyStats.jobsFetched,
      remaining: Math.max(0, 100 - dailyStats.jobsFetched),
      date: dailyStats.date
    },
    nextFetchTime: nextFetch ? nextFetch.toISOString() : null,
    recentHistory: fetchHistory.slice(-5) // Last 5 fetch entries
  };
}

case 'GET_NEXT_FETCH_TIME': {
  const nextTime = await getNextFetchTime();
  return { nextFetchTime: nextTime ? nextTime.toISOString() : null };
}

case 'UPDATE_FETCH_SCHEDULE': {
  // User changed fetch time in settings
  const { hour, minute } = message;
  await scheduleDailyFetch(hour, minute);
  const nextTime = await getNextFetchTime();
  return { success: true, nextFetchTime: nextTime ? nextTime.toISOString() : null };
}
```

**Preserve ALL existing code** that is not being modified (TEST_API_CONNECTION, CHECK_DAILY_CAP, GET_ONBOARDING_STATUS handlers, checkDailyCap helper, testApiConnection function). Do NOT remove any existing functionality.

The `checkDailyCap` function stays as-is â€” it's used by the existing CHECK_DAILY_CAP message handler and still needed.
  </action>
  <verify>
Read the updated src/background.js and confirm:
1. New imports at top: scheduleDailyFetch, verifyAlarmExists, getNextFetchTime from scheduler.js; runJobFetch, resumeJobFetch from job-fetcher.js
2. onInstalled creates alarm via scheduleDailyFetch() instead of raw chrome.alarms.create
3. onInstalled initializes default settings on first install
4. onStartup verifies alarm via verifyAlarmExists() and recovers batch progress via resumeJobFetch()
5. Alarm listener has smart catch-up logic (>120 min delay + already fetched today = skip)
6. Four new message handlers: TRIGGER_FETCH, GET_FETCH_STATUS, GET_NEXT_FETCH_TIME, UPDATE_FETCH_SCHEDULE
7. All existing handlers preserved: GET_ONBOARDING_STATUS, CHECK_DAILY_CAP, TEST_API_CONNECTION
8. checkDailyCap helper function and testApiConnection function unchanged
9. keepAlive import still present
10. No syntax errors (all braces/brackets balanced)
  </verify>
  <done>background.js fully integrated with fetch pipeline: alarm-triggered daily fetching, missed alarm handling, startup recovery, and manual fetch/status message handlers</done>
</task>

</tasks>

<verification>
After task completes:
1. background.js imports scheduler.js and job-fetcher.js
2. Daily alarm uses scheduleDailyFetch() for timezone-aware scheduling
3. Alarm fires -> smart catch-up check -> runJobFetch()
4. Service worker restart -> verifyAlarmExists() + resumeJobFetch()
5. Popup can send TRIGGER_FETCH message to manually trigger fetch
6. Popup can send GET_FETCH_STATUS to get current state for UI
7. Popup can send UPDATE_FETCH_SCHEDULE to change fetch time
8. All existing message handlers still work (onboarding, API testing, daily cap)
</verification>

<success_criteria>
- Alarm fires and triggers the full fetch pipeline automatically
- Missed alarms after device sleep are handled with smart catch-up policy
- In-progress fetches are recovered on service worker restart
- Manual fetch trigger available via message passing
- Fetch status queryable via message passing for UI display
- All existing background.js functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/03-job-fetching-scheduling/03-03-SUMMARY.md`
</output>
