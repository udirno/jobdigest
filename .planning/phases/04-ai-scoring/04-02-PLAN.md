---
phase: 04-ai-scoring
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/job-fetcher.js
  - src/background.js
autonomous: true

must_haves:
  truths:
    - "After jobs are fetched, they are automatically scored before the pipeline completes"
    - "Scoring runs within keep-alive to prevent service worker termination"
    - "User can check scoring status via message passing from popup/settings UI"
    - "Scoring failures do not break the fetch pipeline -- partial results are preserved"
    - "Scored jobs persist in storage with score, reasoning, and dimension details visible"
  artifacts:
    - path: "src/job-fetcher.js"
      provides: "Fetch pipeline with integrated scoring stage"
      contains: "scoreUnscoredJobs"
    - path: "src/background.js"
      provides: "Message handlers for scoring status and manual scoring trigger"
      contains: "SCORE_JOBS|GET_SCORING_STATUS"
  key_links:
    - from: "src/job-fetcher.js"
      to: "src/job-scorer.js"
      via: "scoreUnscoredJobs import and call after fetch stages"
      pattern: "import.*scoreUnscoredJobs.*job-scorer"
    - from: "src/background.js"
      to: "src/job-scorer.js"
      via: "SCORE_JOBS message handler triggers scoring"
      pattern: "scoreUnscoredJobs|scoreSingleJob"
    - from: "src/job-fetcher.js"
      to: "src/keep-alive.js"
      via: "withKeepAlive wraps the combined fetch+score operation"
      pattern: "keepAlive\\.withKeepAlive"
---

<objective>
Wire the AI scoring engine into the existing fetch pipeline and background message system so scoring happens automatically after each fetch and can be triggered manually.

Purpose: Plan 01 created the scoring modules. This plan connects them to the live system: job-fetcher.js calls scoring after fetching, background.js exposes message handlers for UI integration. The existing keep-alive mechanism protects the full fetch+score operation from service worker termination.

Output: Modified `src/job-fetcher.js` (scoring stage added to pipeline) and `src/background.js` (new message handlers for scoring).
</objective>

<execution_context>
@/Users/udirno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/udirno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-scoring/04-01-SUMMARY.md

# Files being modified
@src/job-fetcher.js
@src/background.js

# Dependencies
@src/job-scorer.js
@src/storage.js
@src/keep-alive.js
@src/errors.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scoring stage to job-fetcher pipeline</name>
  <files>src/job-fetcher.js</files>
  <action>
Modify `src/job-fetcher.js` to add a scoring stage after the fetch pipeline completes.

**Changes:**

1. Add import at top:
   ```javascript
   import { scoreUnscoredJobs } from './job-scorer.js';
   ```

2. In `executeFetchPipeline()`, after the final `updateAdaptiveMetrics()` call and daily stats update, add a scoring stage:

   ```javascript
   // Score newly fetched jobs
   console.log('Starting AI scoring for fetched jobs...');
   try {
     const scoreResult = await scoreUnscoredJobs();
     console.log(`Scoring complete: ${scoreResult.scored} scored, ${scoreResult.failed} failed`);
     historyEntry.scoringResult = {
       scored: scoreResult.scored,
       failed: scoreResult.failed,
       status: scoreResult.status
     };
   } catch (error) {
     console.error('Scoring stage failed:', error);
     historyEntry.errors.push(`Scoring: ${error.message}`);
     // Do NOT rethrow -- fetch was successful even if scoring fails
   }
   ```

   CRITICAL: Scoring failure must NOT cause the fetch pipeline to fail. The fetch result should still be 'success' if jobs were fetched, even if scoring fails. Wrap in try/catch and push error to historyEntry.errors.

3. Add scoring result to the return objects in `runJobFetch()`:
   - In the success return block, add `scoringResult: historyEntry.scoringResult || null`
   - In the error return block, same addition

4. In `resumeJobFetch()`, add the same scoring result forwarding.

5. Update batch progress stages -- add 'scoring' as a conceptual stage in the comments but do NOT add it as an actual checkpoint stage in the fall-through switch. Scoring runs after the switch completes.

IMPORTANT: The keep-alive is already wrapping the `executeFetchPipeline` call via `keepAlive.withKeepAlive('job-fetch', ...)` in `runJobFetch()`. Since scoring now runs inside `executeFetchPipeline`, it is automatically protected by keep-alive. No changes needed to keep-alive wiring.

Do NOT change the checkpoint/stage system (bootstrap-adzuna, bootstrap-jsearch, adaptive-allocation, remaining-fetch). Scoring is appended after these stages, not inserted into the switch.
  </action>
  <verify>
Read src/job-fetcher.js and verify:
1. Import of scoreUnscoredJobs from job-scorer.js exists
2. Scoring stage is called AFTER fetch stages and daily stats update
3. Scoring failure is caught and does NOT propagate (try/catch with error pushed to historyEntry.errors)
4. scoringResult is included in return objects from runJobFetch
5. The 4-stage checkpoint switch (bootstrap-adzuna through remaining-fetch) is unchanged
6. Keep-alive already covers scoring (no new keep-alive calls added)
  </verify>
  <done>
job-fetcher.js pipeline runs scoring after fetching. Scoring failures are isolated -- they do not crash the fetch pipeline. Scoring results are included in the fetch return object for UI consumption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add scoring message handlers to background service worker</name>
  <files>src/background.js</files>
  <action>
Modify `src/background.js` to add message handlers for scoring operations.

**Changes:**

1. Add import at top:
   ```javascript
   import { scoreUnscoredJobs } from './job-scorer.js';
   ```

2. Add new message handler cases in the `handleMessage` switch:

   ```javascript
   case 'SCORE_JOBS': {
     // Manual scoring trigger (e.g., after resume upload or re-score request)
     console.log('Manual scoring triggered');
     try {
       const result = await keepAlive.withKeepAlive('ai-scoring', async () => {
         return await scoreUnscoredJobs();
       });
       return { success: true, ...result };
     } catch (error) {
       console.error('Manual scoring failed:', error);
       return { success: false, error: error.message };
     }
   }

   case 'GET_SCORING_STATUS': {
     // Return scoring state for UI display
     const jobs = await storage.getJobs();
     const jobList = Object.values(jobs);
     const scored = jobList.filter(j => j.score !== null && j.score !== undefined && j.score >= 0).length;
     const unscored = jobList.filter(j => j.score === null || j.score === undefined).length;
     const failed = jobList.filter(j => j.score === -1).length;
     const total = jobList.length;

     return {
       scored,
       unscored,
       failed,
       total,
       averageScore: scored > 0
         ? Math.round(jobList.filter(j => j.score >= 0).reduce((sum, j) => sum + j.score, 0) / scored)
         : null
     };
   }
   ```

3. Add `keepAlive` import if not already imported (it is not currently imported in background.js -- check first):
   - The keepAlive is needed for the SCORE_JOBS handler since manual scoring happens outside the fetch pipeline's keep-alive wrapper.
   - Add: `import { keepAlive } from './keep-alive.js';`

IMPORTANT: The SCORE_JOBS handler wraps scoring in `keepAlive.withKeepAlive('ai-scoring', ...)` because manual scoring runs outside the fetch pipeline. This is separate from the fetch pipeline's 'job-fetch' keep-alive tag.

The GET_SCORING_STATUS handler provides a quick snapshot by reading from storage (no API calls), so it does not need keep-alive.
  </action>
  <verify>
Read src/background.js and verify:
1. Import of scoreUnscoredJobs from job-scorer.js exists
2. Import of keepAlive from keep-alive.js exists
3. SCORE_JOBS case exists in handleMessage switch with keep-alive wrapper
4. GET_SCORING_STATUS case exists and returns scored/unscored/failed/total/averageScore
5. SCORE_JOBS returns { success: true/false } pattern matching existing message handler conventions
6. Error handling follows existing pattern (try/catch, return error message)
  </verify>
  <done>
background.js handles SCORE_JOBS (manual scoring trigger with keep-alive) and GET_SCORING_STATUS (quick stats from storage). Both follow existing message handler conventions. Manual scoring is protected by keep-alive. Status queries are lightweight storage reads.
  </done>
</task>

</tasks>

<verification>
1. Job fetcher pipeline: fetch -> score -> save (scoring appended, not inserted into checkpoint stages)
2. Scoring failure isolation: fetch succeeds even if scoring fails
3. Manual scoring: SCORE_JOBS message triggers scoring with keep-alive protection
4. Status query: GET_SCORING_STATUS returns counts from storage (no API calls)
5. Keep-alive coverage: automatic scoring covered by fetch pipeline's keep-alive, manual scoring has its own keep-alive
6. No breaking changes to existing message handlers or alarm handlers
7. Return objects include scoringResult for UI consumption
</verification>

<success_criteria>
- Fetched jobs are automatically scored after the fetch pipeline completes
- Scoring failures do not crash or fail the fetch pipeline
- SCORE_JOBS message handler triggers manual scoring with keep-alive
- GET_SCORING_STATUS returns scored/unscored/failed counts
- All scored jobs have score (0-100 or -1 for failed), scoreReasoning, scoredAt, and scoreDetails in storage
- Existing fetch pipeline stages (bootstrap through remaining-fetch) are unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-scoring/04-02-SUMMARY.md`
</output>
